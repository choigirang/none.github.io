---
title:  "TypeScript 3장 - 러닝 타입스크립트(2)"
excerpt: ""

categories: TypeScript
tags: [타입스크립트, TypeScript, 타입시스템, 문서화, 컴파일, 자바스크립트, 애너테이션 ]

toc: true
toc_sticky: true
 
date: 2023-03-02
last_modified_at: 2023-03-02
---
# TypeScript

![image](https://user-images.githubusercontent.com/118104644/222047360-4f48f5be-c478-4d62-b23e-8c77e933d674.png){: .center}

## Part.1
### chapter.3
- **유니언** : 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것
- **내로잉** : 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 좁히는 것


#### 3.1 유니언 타입
```typescript
let mathmatician = Math.random() > 0.5
  ? undefined
  : "Mark Goldberg" ;
```
- `mathmatician`은 `undefined`이거나 `string`일 수 있다.
- 이처럼 값이 정확히 어떤 타입인지는 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있을 때, 이를 **유니언**이라고 한다.
- 이렇게 작성된 `mathmatician`은 `string|undefined`로 표현된다.
- 변수 위에 마우스를 가져가면 타입을 표시한다.

##### 3.1.1 유니언 타입 선언
- 변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용한다.
- 초깃값은 `null`이지만 잠재적으로 `string` 될 수 있음을 알린다.
  ```typescript
  let thinker : string|null = null;

  if(Math.randon() > 0.5){
    thinker = "Susanne"; // OK
  }
  ```
- 유니언 타입 선언의 순서는 중요하지 않으며 `boolean|number`와 `number|boolean`은 같다.


##### 3.1.2 유니언 속성
- 값이 유니언 타입일 때, 타입스크립트는 유니언으로 선언하여 접근이 가능한 메서드에만 접근할 수 있다.
- 유니언 외의 타입에 접근하려고 하면 타입 검사 오류가 발생한다.
  ```typescript
  let physicist = Math.random()>0.5
  ? "Marie" : 84;

  physicist.toString(); // OK
  physicist.toUpperCase();
  // Error : Property 'toUpperCase' does not exist on type 'string | number '
  // Property  'toUpperCase' does not exist on type 'number'
  physicist.toFiexd();
  // Error : Property 'toFiexd' does not exist on type 'string | number'
  // Property 'toFiexd' does not exist on type 'string'
  ```
  - 두 타입 모두 사용 가능한 메서드여야 한다.
  - 이러한 여러 개의 타입 중 하나의 타입으로 된 값의 속성을 사용하려면, 값이 보다 구체적인 타입 중 하나라는 것을 타입스크립트에 알려야 한다.
  - 이러한 과정을 **내로잉**이라고 부른다.

#### 3.2 내로잉
- 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것이다.
- 타입스크립트가 값의 타입이 이전에 알려진 것보다 더 좁혀졌다는 것을 알게 되면 값을 더 구체적인 타입으로 취급한다.
- 타입을 좁히는 데 사용하는 논리적 검사를 **타입 가드**라고 한다.

##### 3.2.1 값 할당을 통한 내로잉
- 변수에 값을 할당하면 변수의 타입을 할당된 값의 타입으로 좁힌다.
  ```typescript
  let admiral: number|string;
  admiral = "Grace";

  admiral.toUpperCase(); // OK : string
  admiral.toFixed();
  // Error : Property 'toFixed' does not exist on type 'string'
  ```
  - 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동한다.
  - 타입스크립트는 변수가 나중에 유니언 타입으로 선언된 타입 중 하나의 값을 받을 수 있지만, 처음에는 초기에 할당된 값의 타입으로 시작한다.


  ```typescript
  let inventor: number|string = "Hedy";
  
  inventor.toUpperCase(); // OK string
  inventor.toFixed();
  // Error : Property 'toFixed' does not exist on type 'string'
  ```

##### 3.2.2 조건 검사를 통한 내로잉
- 일반적으로 타입스크립트에서는 변수가 알려진 값과 같은지 확인하는 `if`문을 통해 변수의 값을 좁히는 방법을 사용한다.
- 변수가 알려진 값과 동일한 타입인지 확인한다.
  ```typescript
  let scientist = Math.random() > 0.5
    ? "Rosalind" : 51;
  // scientist : number | string
  if(scientist === "Rosalind"){
    scientist.toUpperCase(); // OK
  }
  // scientist: string 타입
  scientist.toUpperCase();
  // Error : Property "toUpperCase" does not exist on type "string|number"
  // Property "toUpperCase" does not exist on type "number"
  ```
  - 조건부 로직을 내로잉할 때, 만약 변수가 여러 타입 중 하나라면, 일반적으로 필요한 타입과 관련된 검사를 원할 것이다.
  - 타입스크립트는 강제로 코드를 안전하게 작성할 수 있도록 돕는다.


##### 3.2.3 typeof 검사를 통한 내로잉
- 직접 값을 확인해 타입을 좁히기도 하지만, `typeof`연산자를 사용할 수도 있다.
- 타입스크립트의 `if`문에서 타입이 무엇인지 확인한다.
  ```typescript
  let researcher = Math.random() > 0.5
    ? "Rosalind" : 51;

  if(typeof researcher === "string"){
    researcher.toUpperCase(); // OK : string
  }
  ```
- `!`를 사용한 논리적 부정과 `else`문도 잘 작동한다.
  ```typescript
  if(!(typeof researcher === "string")){
    reseacher.toFixed(); // OK : number
  } else{
    researcher.toLowerCase(); // OK : string
  }
  ```
- 삼항 연산자를 이용해 다시 작성할 수 있다.
  ```typescript
  typeof researcher === "string"
    ? researcher.toUpperCase(); // OK : string
    : researcher.toFixed(); // OK : number
  ```


#### 3.3 리터럴 타입
- 원시 타입 값 중 어떤 것이 아닌 특정 **원싯값**으로 알려진 타입이다.
- 원시 타입 `string`은 존재할 수 있는 모든 문자열의 집합을 나타내지만, 리터럴 타입인 `Hypatia`는 하나의 문자열만 나타낸다.
- 만약  변수를 선언하고 직접 리터럴 값을 할당하면, 타입스크립트는 해당 변수에 할당된 리터럴 값으로 유추한다.
- 타입 애너테이션에서는 리터럴과 원시 타입을 섞어서 사용할 수 있다.

  ```typescript
  let lifespan: number|"ongoing"|"uncertain";

  lifespan = 89; // OK
  lifespan = "ongoing"; // OK

  lifespan = true;
  // Error : Type 'true' is not assignable to 'number|"ongoing"|"uncertain"'
  lifespan = "hi";
  // Error : Type '"hi"' is not assignable to 'number|"ongoing"|"uncertain"'
  ```


  
  ```typescript
  boolean : true | false
  null 과 undefined 는 자기자신만을 리터럴 값으로 가진다.
  number: 0|1|2...|0.1|0.2|...
  string: ""|"a"|"b"|"c"|...|"aa"|"ab"|..
  ```


#### 3.3 리터럴 할당 가능성
- 0과 1은 동일한 원시 타입을 갖고 있지만 다른 리터럴 타입이기 때문에 할당할 수 없다.

  ```typescript
  let special: "Ada";
  special = "Ada"; // OK
  special = "Bda";
  // Error : Type "Bda" is not assignable to type "Ada".

  let someString = "";
  someString = special; // OK

  let someString2 : "";
  someString2 = special;
  // Error : Type "Ada" is not assignable to type '""';
  ```


#### 3.4 엄격한 null 검사
- **엄격한 null검사**는 모든 데이터 타입에 `null`과 `undefined`를 할당 받을 시 오류를 출력한다.
- `null`타입이 설정된 변수에 `undefined`를 할당할 수 없고, `undefined`타입이 설정된 변수에 `null`을 할당받을 수 없다.
- `tsconfig.json`에 `"strictNullChecks": true`로 설정되어 엄격한 `null`검사를 사용하는 것인데, 만약 `null`,`undefined`를 항상 서브 타입으로 할당할 수 있게 해주려면 `false`값으로 변경하면 된다.
- 혹은 **애너테이션** 또는 **유니온** 또한 사용할 수 있다.


  ```typescript
  let a : null = null; // OK
  let b : undefined = undefined; // OK

  b = null;
  // Error : Type "null" is not assignable to type "undefined".

  let d : string = null;
  // Error : Type "null" is not assignable to type "string".

  let e:string|null = null; // OK

  // "strictNullChecks": false
  let f:string = null; // OK
  ```

##### 3.4.1 십억 달러의 실수
- `null` 값을 사용하도록 허용하는 시스템을 말한다.
- 다음 코드에서 `strictNullChecks`는 비활성화한다면 코드의 타입이 안전하다고 간주되지만 이는 잘못된 것이다.


  ```typescript
  let nameMaybe = Math.random() > 0.5
    ? "Tony"
    : undefined;

  nameMaybe.toLowerCase();
  ```

  - 위 예제는 무작위로 출력되는 숫자가 만약 0.5를 넘는다면, `nameMaybe`는 `Tony`라는 값을 갖게 되고, 이 외의 경우에는 `undefined`를 갖게 된다.
  - `undefined`에는 `toLowerCase` 메서드를 사용할 수 없지만, `strictNullChecks`를 비활성화 했기 때문에 이를 인식하지 못 한다.
  - 이를 활성화 시켜주거나 `if`문으로 활용해 처리해야 한다.

  ```typescript
  let nameMaybe = Math.random() > 0.5
    ? "Tony"
    : undefined;

  nameMaybe.toLowerCase();
  // Error : Object is possibly 'undefined'.

  if(nameMaybe){
    nameMaybe.toLowerCase(); // OK
  }
  ```

##### 3.4.2 참 검사를 통한 내로잉
- 자바스크립트에서 **참** 또는 **truthy**는 `&&`연산자 또는 `if`문처럼 `true`로 간주된다.
- `false`,`0`,`-0`,`0n`,`""`,`null`,`undefined`,`NaN`은 `falsy`로 정의되어 `false`로 간주된다.
  - 논리 연산자는 참 여부를 검사하는 일도 수행하지만, 참 여부 확인 외에 다른 기능은 제공하지 않기 때문에, 만약 값이 `falsy`라면 그것이 빈 문자열인지 `undefined`인지 알 수 없다.
  - 빈 문자열은 `string` 타입을 갖고는 있지만 `falsy`로 정의된다.
    - 따라서 `toLowerCase` 등의 `string` 메서드를 사용할 수는 없지만 이것을 인식할 수 없다.

  ```typescript
  let geneticist = Math.random() > 0.5
    ? "Barbara"
    : undefined;

  if(geneticist){
    geneticist.toLowerCase(); // OK: string
  }

  geneticist.toUpperCase();
  // Error : Object is possibly 'undefined'.
  geneticist && geneticist.toUpperCase(); // OK: string|undefined
  geneticist?.toLowerCase(); // OK: string|undefined
  ```


##### 3.4.3 초깃값이 없는 변수
- 자바스크립트에서 초깃값이 없는 변수는 기본적으로 `undefined`를 갖고, 타입스크립트는 값이 할당되기 전에 접근하려고 한다면 오류를 나타낸다.
- `?.` 연산자는 오ㅂ ㅂ셔널 체이닝을 적용하고, 옵셔널 체이닝은 해당 값이 존재하지 않는 경우, `undefined`일 때도 오류를 발생시키지 않고 `undefined`를 반환한다.
- `mathematician`이 `null` 같은 값이 들어있을 경우 오류가 발생할 수 있다.
- `undefined` 값이 들어가 있는 변수를 사용할 때는 `?.`연산자를 사용하여 옵셔널 체이닝을 적용하도록 권장한다.

  ```typescript
  let mathematician: string;
  mathematician?.length;
  // Error : Variable 'mathematician' is used before being assigned.

  mathematician = "Mark";
  mathematician.length; // OK: string
  ```

#### 3.5 타입 별칭
- 조금 긴 유니언 타입을 가진 경우, 이를 묶어 쉬운 이름을 할당하는 **타입 별칭**이 있다.

  ```typescript
  let raw: boolean|string|number|null|undefined;
  let raw1: boolean|string|number|null|undefined;
  let raw2: boolean|string|number|null|undefined;
  // 타입 별칭
  type RawData = boolean|string|number|null|undefined;
  let raw: RawData;
  let raw1: RawData;
  let raw2: RawData;
  ```


##### 3.5.1 타입 별칭은 자바스크립트가 아니다.
- 타입 별칭은 애너테이션처럼 자바스크립트로 컴파일되지 않는다.
  - 타입스크립트 타입 시스템에만 존재한다.
- 타입 별칭은 타입 시스템에만 존재하기 때문에 런타임 코드에서는 참조할 수 없으며, 이에 접근하려고 하면 타입 오류를 나타낸다.

  ```typescript
  // 3.5의 코드의 자바스크립트 컴파일
  let raw;
  let raw1;
  let raw2;
  ```

  ```typescript
  type SomeType = string|undefined;

  cosole.log(SomeType);
  // Error : 'SomeType' only refers to a type, but is being used as a value here.
  ```


##### 3.5.2 타입 별칭 결합
- 타입 별칭은 다른 타입 별칭을 참조할 수 있으며, 참조할 타입 별칭을 나중에 선언해도 된다.
  ```typescript
  type Id = number|string;
  type IdMaybe = Id|undefined|null;
  // Id = number|string|undefined|null

  type Id2 = Id3|number|string|undefined;
  type Id3 = boolean;
  ```

#### 3.6
- 유니언 타입으로 두 개 이상의 타입 중 하나를 나타낼 수 있다.
- 타입 애너테이션으로 유니언 타입을 명시적으로 표현할 수 있다.
- 타입 내로잉으로 값의 가능한 타입을 좁힐 수 있다.
- 리터럴 타입을 선언할 때는 `const`를 사용하여 할당하는 것이 안정적이다.
  - 원시 타입이 아닌 리터럴 타입을 할당할 떄는 구체적인 값을 할당하는데, `let` 키워드를 사용하면 이 값은 언제든지 재할당 될 수 있기 때문에 타입의 안정성을 잃게 된다.
  - 따라서 리터럴 타입을 사용할 떄, 값을 변경할 필요가 없을 때는 `const`를 사용하여 타입의 안정성을 높인다.
- 타입스크립트에서 `strictNullChecks`를 활성화하여 엄격한 `null`검사를 할 수 있다.
- 존재하지 않을 수 있는 값이나 할당되지 않은 변수는 `undefined`를 갖는다.
- 반복적으로 사용하고자하는 타입은, 타입 별칭에 저장하여 사용할 수 있다.

### chap.4
#### 4.1 객체 타입
- 객체 리터럴을 생성하면, 값과 동일한 속성명과 원시 타입을 갖게 된다.
- 값의 속성에 접근하려면 `value.key` , `value[key]`로 접근을 해야한다.
  
  ```typescript
  const poet = {
    born: 1935,
    name: "Mary"
  };

  poet.born; // number
  poet[name]; // string
  poet.end;
  // Error: Property 'end' does not exist on type '{born: number, name: string}'.
  ```

##### 4.1.1 객체 타입 선언
```typescript
let poet: {
  born: number,
  name: string
};

poet = {
  born: 1954,
  name: "Mary"
};

poet = "sara";
// Error: Type 'string' is not assignable to type '{born: number, name: string}'.
```

##### 4.1.2 별칭 객체 타입
- 마찬가지로 별칭 타입을 사용할 수 있다.
  ```typescript
  type Poet = {
    born: number,
    name: string
  };

  let poet: Poet; // OK

  poet = {
    born: 1935,
    name: "Mary"
  };

  poet = "sara"
  // Error: Type 'string' is not assignable to type '{born: number, name:string}'.
  ```

#### 4.2 구조적 타이핑
- 타입스크립트의 타입 시스템은 **구조적으로 타입화**되어 있다.
- 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 수 있으며, 매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 한다.
- 구조적 타이핑은 **덕 타이핑**과는 다르며, 타입스크립트의 타입 검사기에서 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우이다.
- 덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말한다.
- 자바스크립트는 **덕 타입**인 반면 타입스크립트는 **구조적으로 타입화**된다.

  ```typescript
  type WithFirstName = {
    firstName: string;
  };

  type WithLastName = {
    lastName: string;
  };

  const hasBoth = {
    firstName: 'Mary',
    lastName: 'chang'
  };

  let withFirstName: WithFirstName = hasBoth;
  // OK: 'hasBoth'는 'string'타입의 'firstName'을 포함한다.
  let withLastName: WithLastName = hasBoth;
  // OK: 'hasBoth'는 'string'타입의 'lastName'을 포함한다.
  ```

##### 4.2.1 사용 검사
- 