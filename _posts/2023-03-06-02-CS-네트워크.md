---
title: "CS 7장 - 네트워크"
excerpt: "TCP/IP/HTTP 이해하기"

categories: CS
tags: [기술면접, 네트워크, TCP, IP, HTTP, Header]

toc: true
toc_sticky: true

date: 2023-03-06
last_modified_at: 2023-03-06
---

# CS

![image](https://user-images.githubusercontent.com/118104644/223000758-b743f1c7-38a1-4271-960d-bc02dc09b0ae.png){: .center}

## 네트워크

### IP(인터넷 프로토콜)

- IP는 지정한 IP주소에 `패킷`이라는 통신 단위로 데이터를 전달한다.
- 패킷에는 출발지와 목적지 IP 등의 관한 정보가 담겨있다.
- 패킷 단위로 전송을 하면, 하나의 서버 컴퓨터인 각 노드들이 이를 전달하게 되고, 끝내 정확한 목적지에 도착할 수 있게 된다.
- 서버에 데이터가 무사히 도착하면 서버도 이에 대한 응답을 보내준다.

- 단점
  - 만약 패킷을 받을 대상이 없거나 서비스가 불가능한 상태여도 패킷을 그대로 전송하게 된다.
    - 서버의 상태를 파악할 수 있는 방법이 없다.
  - 중간에 패킷을 전송하는 서버가 데이터를 잃게 되거나 장애가 생겨도 이를 파악할 방법이 없다.
  - 전달하고자 하는 데이터가 큰 경우, 이를 패킷 단위로 나눠 데이터를 전송하게 되는데, 도착하는 패킷의 순서가 의도한 것과 다를 수 있다.

### TCP

- IP 프로토콜 계층보다 더 높은 계층에 있는 TCP가 있다.
- 만약 메세지를 전송하는 과정이 있다고 할 때,
  - 프로그램이 메세지를 생성하고 이를 **SOCKET**에 전달한다.
  - TCP 정보를 생성하고 메세지 데이터를 그 안에 포함시킨다.
  - IP 패킷을 생성하여 TCP 데이터를 포함시킨 후 전송한다.
- TCP 세그먼트에는 IP 패킷의 출발지 IP와 목적지 정보를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등이 포함되어 있다.

#### TCP 연결방식

1. 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 보낸다.
2. 서버가 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN가 설정된 패킷을 발송하고, 클라이언트가 다시 서버로 ACK 보내 연결이 성립되며 데이터를 전송한다.
3. 만약 서버가 꺼져있다면 클라이언트가 SYN을 보내고 서버에서 응답이 없기 때문에 데이터를 보내지 않는다.
   1. 현재에는 최적화가 이루어져 클라이언트가 ACK를 보낼 때 데이터를 함께 보내기도 한다.

- 서버의 응답을 받아 데이터를 전송하기 때문에, IP 패킷의 한계인 비연결성을 보완할 수 있다.
- 만약 패킷이 순서대로 도착하지 않았다면, TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청학 되어 IP 패킷의 순서를 보장하지 않는 비신뢰성을 보완할 수 있다.

### UDP

- UDP는 IP에 PORT, 페크섬 필드 정보만 추가된 단순한 프로토콜이다.
- TCP와 비교하면 신뢰성은 낮지만 빠른 속도를 보장한다.
- 데이터의 전달이나 순서를 보장하진 않는다.
- 신뢰성보다 연속성이 중요한 실시간 스트리밍 서비스 등에 주로 사용된다.

### OSI7 계층모델

- ISO(Internatinal Organization for Standardization) 국제표준화기구에서 제정한 표준 규약이다.
- 네트워크 유형에 관계없이 상호 통신이 가능한 규약, 프로토콜이다.

- 1계층 - 물리 계층
  - 맨 밑에 있는 계층으로, 시스템 간의 물리적인 연결과 전기 신호를 변환 및 제어하는 객체이다.
  - 주로 물리적 연결과 관련된 정보를 정의하며 전기 신호를 전달하는ㄷ 초점을 두어 신호를 잘 전달하는 목적을 갖고 있다.
- 2계층 - 데이터링크 계층
  - 네트워크 기기 간의 데이터 전송 및 물리주소를 결정하는 계층이다.
  - 물리 계층에서 들어온 전기 신호를 알아 볼 수 있는 데이터 형태로 처리한다.
  - 주소 정보를 정의하고 출발지와 도착지 주소를 확인 후 데이터 처리를 수행한다.
- 3계층 - 네트워크 계층
  - OSI 7계층에서 가장 복잡한 계층 중 하나로, 실제 네트워크 간 데이터 라우팅을 담당한다.
  - 어떤 네트워크 안에서 통신 데이터를 짜여진 알고리즘에 의해 최대한 빠르게 보낼 최적의 경로를 선택하는 과정을 말한다.
- 4계층 - 전송 계층
  - 컴퓨터간 신뢰성 있는 데이터를 주고받을 수 있도록 하는 서비스를 제공하는 계층이다.
  - 하위 계층에서 신호와 데이터를 올바른 위치로 보내고 신호를 만드는데 집중했다면, 전송 계층에서는 해당 데이터들이 정상적으로 보내지는지를 확인한다.
  - 네트워크 계층에서 사용되는 패킷은 유실되거나 순서가 바뀌는 경우가 있는 데, 이를 바로 잡아준다.
- 5계층 - 세션 계층
  - 세션 연결의 설정과 해제, 세션 메시지 전송 등의 기능을 수행하는 계층이다.
  - 컴퓨터간의 통신 방식에 대해 결정하는 계층이다.
  - 프로세스가 연결을 성립하도록 도와주고, 작업을 마친 후에는 연결을 끊는 역할을 한다.
- 6계층 - 표현 계층
  - 응용 계층에서 전달하거나 전달받은 데이터를 인코딩 또는 디코딩하는 계층이다.
  - 일종의 변역기 같은 역할을 수행하는 계층이라고 볼 수 있다.
- 7계층 - 응용 계층
  - 최종적으로 사용자와의 인터페이스를 제공하는 계층으로 사용자가 실행하는 응용 프로그램들이 해당 계층에 속한다.

### 데이터 캡슐화

![image](https://user-images.githubusercontent.com/118104644/223004305-cb0c6f61-553f-4bba-993e-3de36743b386.png){:.center}

- 송신 측과 수신 측의 7계층을 통해 데이터를 주고 받는데, 각 계층은 독립적으로 존재하기 때문에 데이터가 전달되는 동안 다른 계층의 영향을 받지 않는다.
- 데이터를 전송하는 측은 상위 계층에서 하위 계층으로 데이터를 전달한다.
- 데이터를 상대방에게 보낼 때 각 계층에서 필요한 정보를 데이터에 추가하는데, 이를 **헤더(데이터 링크 계층에서는 트레일러)**라고 한다.
- 그리고 이렇게 헤더를 붙여나가는 것을 **캡슐화**라고 한다.
- 마지막 물리 계층에 도달하면 송신 측의 데이터링크 계층에서 만들어진 데이터가 전기 신호로 변환되어 수신 측에 전송된다.
- 데이터를 받는 쪽은 하위 계층에서 상위 계층으로 각 계층을 통해 전달된 데이터를 받게 된다.
- 데이터를 전달하며 각 게층에서 헤더를 제거해 나가는 것을 **역캡슐화**라고 한다.
- 역캡슐화를 거쳐 응용 계층에 도달하면 원본 데이터만 남게 된다.

### TCP/IP 4계층 모델

- OSI 모델을 기반으로 실무적으로 이용할 수 있도록 단순화된 모델이다.

- 4 계층 : 어플리케이션 게층
  - OSI 게층의 세션 게층, 표현 계층, 응용 계층에 해당하며 TCP/UDP 기반의 응용프로그램을 구현할 때 사용한다.
- 3 게층 : 전송 계층
  - OSI 계층의 전송 계층에 해당하며 통신 노드간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.
- 2 계층 : 인터넷 계층
  - OSI 계층의 네트워크 계층에 해당하며 통신 노드 간의 IP 패킷을 전송하는 기능 및 라우팅을 담당한다.
- 1 계층 : 네트워크 인터페이스 계층
  - OSI 계층의 물리 ㄱ층과 데이터 링크 계층에 해당하며 물리적인 주소로 MAC을 사용한다.

#### 응용 계층

![image](https://user-images.githubusercontent.com/118104644/223005281-1fda03de-4ef7-45f3-b597-0b0ad44b6bf6.png){:.center}

### HTTP

- 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있다.
- HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다.
- 카페에서 음료를 주문할 때, 손님을 받은 점원이 A이고 중간에 바쁜 일이 생겨 A의 주문을 B점원이 대신 받게 되었을 때, 현재까지 의 주문 내용을 B도 기억하고 있으며, C라 바뀌었을 때도 기억하고 있어 차질없는 주문이 가능하다.
  - 갑자기 고객이 증가해도 점원을 대거 투입할 수 있으며 클라이언트의 요청이 증가해도 서버를 대거 투입할 수 있다.
  - 무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다.
- 만약 상태유지라면 중간에 다른 점원이 바뀌면 안된다.
  - 중간에 다른 점원에게 상태 정보를 미리 알려줘야 한다.
  - 사용하고 있는 서버에 장애가 생겨 서버를 바꿔야하는 상황에서 유지되던 상태 정보를 다시 요청해야 한다.

#### 무상태

- 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
- 로그인이 필요없는 단순한 소개 화면은 무상태로 섥해도 되지만, 로그인 됐다면 상태를 유지해야 하며 로그인한 사용자의 경우 로그인했다는 상태를 서버에 유지한다.
- 상태 유지는 최소한만 사용한다.
- TCP/IP의 경우 기본적으로 연결을 유지하며, 서버의 자원이 계속 소비된다.
- 비연결성을 가지는 HTTP에서는 실제로 요청을 주고받을 때만 연결을 유지하고, 응답을 주고 나면 TCP/IP연결을 끊는다.
  - 이를 통해 최소한의 자원으로 서버 유지가 가능하다.
- 비연결성 또한 한계를 가지는데, 웹브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트, CSS, 이미지 등 수많은 자원이 함께 다운로드 된다.
  - 해당 자원들을 각각 보낼 때마다 연결을 끊고 연결을 반복하는 것은 비효율적이기 때문에 지금은 지속 연결을 한다.

#### HTTP Headers

![image](https://user-images.githubusercontent.com/118104644/223029816-89222123-de44-4096-a11d-c1654697047a.png){:.center}

- HTTP 바디에서는 데이터 메시지 본문을 통해 표현 데이터를 전달한다.
  - 데이터를 실어 나르는 부분을 페어로드라고 한다.
- 헤더 형식 <field-name> : <field value>로 구성된다.
  ![image](https://user-images.githubusercontent.com/118104644/223030748-f4ef8a3d-af44-4335-86a0-a7aa637d88fe.png){:.center}
- HTTP 헤더는 전송에 필요한 모든 부가정보를 담기 위해 사용한다.
- 표현 데이터
  - Content-Type: text/html; charset=UTF-8 표현 데이터의 형식
  - Content-Encoding: utf-8 표현 데이터의 압축 방식
  - Content-Language: 표현 데이터의 자연 언어
  - Content-length: 표현 데이터의 길이
  - 요청과 응답 모두 표현 데이터를 사용한다.

##### 요청에 사용되는 헤더

- Form

  - 유저 에이전트의 임일 정보
  - 일반적으로 잘 사용하지 않는다.
  - 검색 엔진에서 주로 사용한다.
  - 요청에서 사용한다.

- Referer

  - 이전 웹 페이지 주소
  - 현재 요청된 페이지의 이전 웹 페이지 주소를 말한다.
  - A에서 B로 이동하는 경우, B를 요청할 때 `Referer: A`를 포함해서 요청한다.
  - `Referer`를 사용하면 유입경로를 수집할 수 있다.
  - 요청에서 사용한다.

- User-Agent

  - 유저 에이전트 애플리케이션 정보
  - 클라이언트의 애플리케이션 정보(웹 브라우저 정보 등)
  - 통계 정보
  - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
  - 요청에서 사용한다.

- Host
  - 요청한 호스트 정보(도메인)
  - 요청에서 사용하며 필수 헤더이다.
  - 하나의 서버가 여러 도메인을 처리해야 할 때 호스트 정보를 명시하기 위해 사용한다.
  - 하나의 IP주소에 여러 도메인이 적용되어 있을 때 호스트 정보를 명시하기 위해 사용한다.

![image](https://user-images.githubusercontent.com/118104644/223032284-e7183eba-af52-4508-81a2-945e80b74e82.png){:.center}

- Origin

  - 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타낸다.
  - 여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS에러가 발생한다.
  - 응답 헤더의 Access Control-Allow Origin과 관련된다.

- Authorization
  - 인증 토큰을 서버로 보낼 때 사용하는 헤더

##### 응답에 사용되는 헤더

- Server

  - 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
  - 응답에서 사용한다.
  - Server: Apache/2.2.22(Debian)
  - Server: nginx

- Date

  - 메시지가 발생한 날짜와 시간
  - 응답에서 사용한다.

- Location

  - 페이지 리디렉션
  - 웹 브라우저는 3xx응답의 결과에 `location` 헤더가 있으면 `Location`위치로 자동이동
  - 201(Created): `Location`값은 요청에 의해 생성된 리소스 URI
  - 3xx(Redirection): `Location`값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴

- Allow

  - 허용 가능한 HTTP 메서드
  - 405에서 응답에 포함

- Retry-After
  - 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  - 503(Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있다.
